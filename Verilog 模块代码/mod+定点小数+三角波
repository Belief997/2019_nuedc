/*
	定点小数，即小数点的位置固定，在Verilog里只能做二进制整数的运算（二为除数的除法），故要将小数化为对应的合适的二进制做运算。
	若定义的变量的位宽为 W ，Qm.n （m + n = W）其中m即表示整数
	如有小数 x 要转换成 Qm.n 格式 ，则进行 --> x * 2^n --> 保留整数部分（产生误差） --> 将保留的整数化为二进制  即是对应的定点小数
	Qm.n 二进制转换成小数 ,则进行 --> y / 2^n 即得到小数，两小数相比较可得到误差
	
	定点小数的乘法，得到的总位宽等于两乘数的位宽和，n为 n1+n2 由于小数点的位置是固定的，带符号的要进行带符号移位，同时要对相乘后的结果进行扩位宽，
		Z（Q1.7）= (18'b1 * X(Q0.8) * Y(Q1.9)) >>> 10;  //移位的位数根据乘得的n和结果要保留的n决定

	计算内容
5.555*4.444=24.68642

第一步：将被乘数乘以256
5.555*256 = 1422.08   = 20'd1422 = 20'h5_8E;  (存在误差0.0056%)
4.444*256 = 1137.664 = 20'd1137= 20'h4_71;   (存在误差0.058%)

第二步：中间运算
20'h5_8E * 20'h4_71 = 20'h18_ABAE;

第三步：中间结果除以256
20'h18_ABAE >> 8 = 20'h18_AB;

第四步：转换为实际小数比较
20'h18_AB = 24.171(存在误差2%)

注：1、中间乘法操作时，不存在误差。
    2、如果想降低取整导致的误差，可以加大位宽。（加大 n ）

FROM http://blog.csdn.net/times_poem/article/details/51505014
	变量的位宽固定，Q固定，所能表示的小数范围有限制，我们一般在数字信号处理系统中, 永远把[-1,1]映射到[-127,127]
*/

/*

	m是调制系数Q0.8无符号
	结果有误差
	

*/



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//有符号的必须使用带符号右移 
//如果不带符号右移 100000  移了之后值没变 这是因为有符号数的符号位的1相当于带符号的数值位 所以有符号数移位要带符号
//负数带符号右移是补码的带符号右移，移了之后是正确的补码表示

//该模块是调制模块，输入带符号的10位Q1.9的三角载波 ，输入带符号的8位Q1.7的范围(-1,1)的三角信号波,输入8位Q0.8无符号[0,1]调制系数，输出11位Q2.9的带符号调制信号
//操作： m(调制系数) --> sm(加一位带符号) , 
//				mx --> m * x(t)  (扩位和移位)
//				mx_shift --> mx + 1
//				 sig（输出）--> c(t) * mx_shift + 1
//注意调用该模块时其输入的 m 必须是按 Q0.8 输入
//y(t) = c(t) * (m * x(t) + 1)

module mod
(
	input clk, rst,
	input signed [9:0] c,	// ? Q1.9
	input signed [7:0] x,	// Q1.7
	input [7:0] m,			// ? Q0.8
	output reg signed [10:0] sig // Q2.9
);
	reg signed [7:0] mx;	// Q1.7, (-1,1)
	initial begin
		mx = 8'sd0;
		sig = 11'sd0;
	end
	wire signed [8:0] sm = m;	// Q1.8
	//               1.7   1.8  1.7
	//wire signed [7:0] mx = (17'sd1 * sm * x) >>> 8;
	always@(posedge clk) begin
		if(~rst)
			mx <= (17'sd1 * sm * x) >>> 8;
		else
			mx <= 8'sd0;
	end
	//            Q2.7(0,2)   Q1.7(-1,1)  Q2.7(1)
	wire signed [8:0] mx_shift = mx + (9'sd1 <<< 7);
	always@(posedge clk) begin
	// Q2.9(-2,2)      Q2.7(0,2)   Q1.9(-1,1)
		sig <= (19'sd1 * mx_shift   *   c) >>> 7;
	end
endmodule

///////////////////////////////////////////////////////////////

//////////[-500,500]三角波载波模块//用一次函数向下翻成三角波
//|     /'''''''|'''''''''''''''''
//|    /   ...'.|.........   
//|   /      '__|          
//|  /	-->	/\	|					/\
//| /			 /  \	|				 /	\
//|/			/		 \|				/
//|——————/——————\——————/—————————
//							 \		/					
//							  \	 /
//								 \/
//

///////////////////////
module carr(
	input clk,
	output reg signed [9:0] c
);
	initial c = 10'sd0;
	reg [10:0] acc; initial acc = 11'd0;  //根据载波的频率和幅值实际情况调整计数器的模和步进 频率 幅值 步进 模  模->幅值  步进+模->频率  步进受其他所有因素影响
	always@(posedge clk) begin
		if(acc < 11'd1980)
			acc <= acc + 11'd20;
		else
			acc <= 11'd0;
	end
	always@(posedge clk) begin
		if(acc < 11'd1000)
			c <= acc - 11'd500;
		else
			c <= 11'd1500 - acc;
	end
endmodule

module siggen(
	input clk,
	output reg signed [7:0] x
);
	initial x = 8'sd0;
    //        Q2.22(-2,2)
	reg signed [23:0] pacc; initial pacc = 24'sd0;
	always@(posedge clk) begin
		if(pacc < 24'sh7F_8000)		/*2500 clk time*/   //1.9921875   8，355，840 	//这里 “24'sh7F_8000” 是127左移15位Q1.7-->Q2.22后的结果
			pacc <= pacc + 24'sd6698;//调用根据一个信号周期要多少个时钟周期时改步进  计数器的最大最小值固定（-2.2） 信号的幅值固定 只需调频率 即其一个信号周期内的时钟周期
		else
			pacc <= -24'sh7F_8000;          //
	end
	//             Q1.7(-1,1) Q2.22(-2,2)  Q2.22(1.0)
	wire signed [7:0] yrise = (pacc + (24'sd1 <<< 22)) >>> 15;
//                 Q1.7(-1,1) Q2.22(1.0)  Q2.22(-2,2)
	wire signed [7:0] yfall = ((24'sd1 <<< 22) - pacc) >>> 15;
	always@(posedge clk) begin
		if(pacc < 24'sd0)
			x <= yrise;
		else
			x <= yfall;
	end
endmodule









